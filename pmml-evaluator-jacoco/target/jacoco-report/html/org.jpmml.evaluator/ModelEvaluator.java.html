<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ModelEvaluator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMML class model evaluator code coverage</a> &gt; <a href="index.source.html" class="el_package">org.jpmml.evaluator</a> &gt; <span class="el_source">ModelEvaluator.java</span></div><h1>ModelEvaluator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Villu Ruusmann
 *
 * This file is part of JPMML-Evaluator
 *
 * JPMML-Evaluator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JPMML-Evaluator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with JPMML-Evaluator.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.jpmml.evaluator;

import java.io.Serializable;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.function.Predicate;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.collect.Sets.SetView;
import com.google.common.collect.Table;
import org.dmg.pmml.DataDictionary;
import org.dmg.pmml.DataField;
import org.dmg.pmml.DataType;
import org.dmg.pmml.DefineFunction;
import org.dmg.pmml.DerivedField;
import org.dmg.pmml.Field;
import org.dmg.pmml.FieldName;
import org.dmg.pmml.InlineTable;
import org.dmg.pmml.LocalTransformations;
import org.dmg.pmml.MathContext;
import org.dmg.pmml.MiningField;
import org.dmg.pmml.MiningFunction;
import org.dmg.pmml.MiningSchema;
import org.dmg.pmml.Model;
import org.dmg.pmml.ModelVerification;
import org.dmg.pmml.OpType;
import org.dmg.pmml.Output;
import org.dmg.pmml.PMML;
import org.dmg.pmml.Target;
import org.dmg.pmml.Targets;
import org.dmg.pmml.TransformationDictionary;
import org.dmg.pmml.VerificationField;
import org.dmg.pmml.VerificationFields;

/**
 * @see ModelEvaluatorBuilder
 */
@SuppressWarnings (
	value = {&quot;unused&quot;}
)
abstract
public class ModelEvaluator&lt;M extends Model&gt; implements Evaluator, HasModel&lt;M&gt;, Serializable {

<span class="fc" id="L78">	private PMML pmml = null;</span>

<span class="fc" id="L80">	private M model = null;</span>

<span class="fc" id="L82">	private Configuration configuration = Configuration.getInstance();</span>

<span class="fc" id="L84">	private InputMapper inputMapper = null;</span>

<span class="fc" id="L86">	private ResultMapper resultMapper = null;</span>

<span class="fc" id="L88">	private ValueFactory&lt;?&gt; valueFactory = null;</span>

<span class="fc" id="L90">	private Map&lt;FieldName, DataField&gt; dataFields = Collections.emptyMap();</span>

<span class="fc" id="L92">	private Map&lt;FieldName, DerivedField&gt; derivedFields = Collections.emptyMap();</span>

<span class="fc" id="L94">	private Map&lt;String, DefineFunction&gt; defineFunctions = Collections.emptyMap();</span>

<span class="fc" id="L96">	private Map&lt;FieldName, MiningField&gt; miningFields = Collections.emptyMap();</span>

<span class="fc" id="L98">	private Map&lt;FieldName, DerivedField&gt; localDerivedFields = Collections.emptyMap();</span>

<span class="fc" id="L100">	private Map&lt;FieldName, Target&gt; targets = Collections.emptyMap();</span>

<span class="fc" id="L102">	private Map&lt;FieldName, org.dmg.pmml.OutputField&gt; outputFields = Collections.emptyMap();</span>

<span class="fc" id="L104">	transient</span>
	private Boolean parentCompatible = null;

<span class="fc" id="L107">	transient</span>
	private Boolean pure = null;

<span class="fc" id="L110">	transient</span>
	private List&lt;InputField&gt; inputFields = null;

<span class="fc" id="L113">	transient</span>
	private List&lt;InputField&gt; activeInputFields = null;

<span class="fc" id="L116">	transient</span>
	private List&lt;TargetField&gt; targetResultFields = null;

<span class="fc" id="L119">	transient</span>
	private List&lt;OutputField&gt; outputResultFields = null;

<span class="fc" id="L122">	transient</span>
	private Set&lt;org.dmg.pmml.ResultFeature&gt; resultFeatures = null;


<span class="fc" id="L126">	protected ModelEvaluator(PMML pmml, M model){</span>
<span class="fc" id="L127">		setPMML(Objects.requireNonNull(pmml));</span>
<span class="fc" id="L128">		setModel(Objects.requireNonNull(model));</span>

<span class="fc" id="L130">		DataDictionary dataDictionary = pmml.getDataDictionary();</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">		if(dataDictionary == null){</span>
<span class="nc" id="L132">			throw new MissingElementException(pmml, PMMLElements.PMML_DATADICTIONARY);</span>
		} // End if

<span class="fc bfc" id="L135" title="All 2 branches covered.">		if(dataDictionary.hasDataFields()){</span>
<span class="fc" id="L136">			this.dataFields = CacheUtil.getValue(dataDictionary, ModelEvaluator.dataFieldCache);</span>
		}

<span class="fc" id="L139">		TransformationDictionary transformationDictionary = pmml.getTransformationDictionary();</span>
<span class="fc bfc" id="L140" title="All 4 branches covered.">		if(transformationDictionary != null &amp;&amp; transformationDictionary.hasDerivedFields()){</span>
<span class="fc" id="L141">			this.derivedFields = CacheUtil.getValue(transformationDictionary, ModelEvaluator.derivedFieldCache);</span>
		} // End if

<span class="fc bfc" id="L144" title="All 4 branches covered.">		if(transformationDictionary != null &amp;&amp; transformationDictionary.hasDefineFunctions()){</span>
<span class="fc" id="L145">			this.defineFunctions = CacheUtil.getValue(transformationDictionary, ModelEvaluator.defineFunctionCache);</span>
		}

<span class="fc" id="L148">		MiningFunction miningFunction = model.getMiningFunction();</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">		if(miningFunction == null){</span>
<span class="nc" id="L150">			throw new MissingAttributeException(MissingAttributeException.formatMessage(XPathUtil.formatElement(model.getClass()) + &quot;@functionName&quot;), model);</span>
		}

<span class="fc" id="L153">		MiningSchema miningSchema = model.getMiningSchema();</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">		if(miningSchema == null){</span>
<span class="nc" id="L155">			throw new MissingElementException(MissingElementException.formatMessage(XPathUtil.formatElement(model.getClass()) + &quot;/&quot; + XPathUtil.formatElement(MiningSchema.class)), model);</span>
		} // End if

<span class="fc bfc" id="L158" title="All 2 branches covered.">		if(miningSchema.hasMiningFields()){</span>
<span class="fc" id="L159">			List&lt;MiningField&gt; miningFields = miningSchema.getMiningFields();</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">			for(MiningField miningField : miningFields){</span>
<span class="fc" id="L162">				FieldName name = miningField.getName();</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">				if(name == null){</span>
<span class="nc" id="L164">					throw new MissingAttributeException(miningField, PMMLAttributes.MININGFIELD_NAME);</span>
				}
<span class="fc" id="L166">			}</span>

<span class="fc" id="L168">			this.miningFields = CacheUtil.getValue(miningSchema, ModelEvaluator.miningFieldCache);</span>
		}

<span class="fc" id="L171">		LocalTransformations localTransformations = model.getLocalTransformations();</span>
<span class="fc bfc" id="L172" title="All 4 branches covered.">		if(localTransformations != null &amp;&amp; localTransformations.hasDerivedFields()){</span>
<span class="fc" id="L173">			this.localDerivedFields = CacheUtil.getValue(localTransformations, ModelEvaluator.localDerivedFieldCache);</span>
		}

<span class="fc" id="L176">		Targets targets = model.getTargets();</span>
<span class="pc bpc" id="L177" title="1 of 4 branches missed.">		if(targets != null &amp;&amp; targets.hasTargets()){</span>
<span class="fc" id="L178">			this.targets = CacheUtil.getValue(targets, ModelEvaluator.targetCache);</span>
		}

<span class="fc" id="L181">		Output output = model.getOutput();</span>
<span class="pc bpc" id="L182" title="1 of 4 branches missed.">		if(output != null &amp;&amp; output.hasOutputFields()){</span>
<span class="fc" id="L183">			this.outputFields = CacheUtil.getValue(output, ModelEvaluator.outputFieldCache);</span>
		}
<span class="fc" id="L185">	}</span>

	/**
	 * &lt;p&gt;
	 * Configures the runtime behaviour of this model evaluator.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * Must be called once before the first evaluation.
	 * May be called any number of times between subsequent evaluations.
	 * &lt;/p&gt;
	 */
	public void configure(Configuration configuration){
<span class="fc" id="L198">		setConfiguration(Objects.requireNonNull(configuration));</span>

<span class="fc" id="L200">		setValueFactory(null);</span>

<span class="fc" id="L202">		resetInputFields();</span>
<span class="fc" id="L203">		resetResultFields();</span>
<span class="fc" id="L204">	}</span>

	@Override
	public MiningFunction getMiningFunction(){
<span class="fc" id="L208">		M model = getModel();</span>

<span class="fc" id="L210">		return model.getMiningFunction();</span>
	}

	public MathContext getMathContext(){
<span class="fc" id="L214">		M model = getModel();</span>

<span class="fc" id="L216">		return model.getMathContext();</span>
	}

	public DataField getDataField(FieldName name){

<span class="fc bfc" id="L221" title="All 2 branches covered.">		if(Objects.equals(Evaluator.DEFAULT_TARGET_NAME, name)){</span>
<span class="fc" id="L222">			return getDataField();</span>
		}

<span class="fc" id="L225">		return this.dataFields.get(name);</span>
	}

	/**
	 * @return A synthetic {@link DataField} element describing the default target field.
	 */
	protected DataField getDataField(){
<span class="fc" id="L232">		MiningFunction miningFunction = getMiningFunction();</span>

<span class="pc bfc" id="L234" title="All 3 branches covered.">		switch(miningFunction){</span>
			case REGRESSION:
<span class="fc" id="L236">				MathContext mathContext = getMathContext();</span>

<span class="pc bfc" id="L238" title="All 2 branches covered.">				switch(mathContext){</span>
					case FLOAT:
<span class="fc" id="L240">						return ModelEvaluator.DEFAULT_TARGET_CONTINUOUS_FLOAT;</span>
					default:
<span class="fc" id="L242">						return ModelEvaluator.DEFAULT_TARGET_CONTINUOUS_DOUBLE;</span>
				}
			case CLASSIFICATION:
			case CLUSTERING:
<span class="fc" id="L246">				return ModelEvaluator.DEFAULT_TARGET_CATEGORICAL_STRING;</span>
			default:
<span class="fc" id="L248">				return null;</span>
		}
	}

	public DerivedField getDerivedField(FieldName name){
<span class="fc" id="L253">		return this.derivedFields.get(name);</span>
	}

	public DefineFunction getDefineFunction(String name){
<span class="fc" id="L257">		return this.defineFunctions.get(name);</span>
	}

	public MiningField getMiningField(FieldName name){

<span class="pc bpc" id="L262" title="1 of 2 branches missed.">		if(Objects.equals(Evaluator.DEFAULT_TARGET_NAME, name)){</span>
<span class="nc" id="L263">			return null;</span>
		}

<span class="fc" id="L266">		return this.miningFields.get(name);</span>
	}

	public DerivedField getLocalDerivedField(FieldName name){
<span class="fc" id="L270">		return this.localDerivedFields.get(name);</span>
	}

	public Target getTarget(FieldName name){
<span class="fc" id="L274">		return this.targets.get(name);</span>
	}

	public org.dmg.pmml.OutputField getOutputField(FieldName name){
<span class="fc" id="L278">		return this.outputFields.get(name);</span>
	}

	/**
	 * &lt;p&gt;
	 * Indicates if this model evaluator is compatible with its parent model evaluator.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * A parent compatible model evaluator inherits {@link DataField} declarations unchanged,
	 * which makes it possible to propagate {@link DataField} and global {@link DerivedField} values between evaluation contexts during evaluation.
	 * &lt;/p&gt;
	 */
	public boolean isParentCompatible(){

<span class="fc bfc" id="L293" title="All 2 branches covered.">		if(this.parentCompatible == null){</span>
<span class="fc" id="L294">			this.parentCompatible = assessParentCompatibility();</span>
		}

<span class="fc" id="L297">		return this.parentCompatible;</span>
	}

	/**
	 * &lt;p&gt;
	 * Indicates if this model evaluator represents a pure function.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * A pure model evaluator does not tamper with the evaluation context during evaluation.
	 * &lt;/p&gt;
	 */
	public boolean isPure(){

<span class="fc bfc" id="L311" title="All 2 branches covered.">		if(this.pure == null){</span>
<span class="fc" id="L312">			this.pure = assessPurity();</span>
		}

<span class="fc" id="L315">		return this.pure;</span>
	}

	@Override
	public List&lt;InputField&gt; getInputFields(){

<span class="fc bfc" id="L321" title="All 2 branches covered.">		if(this.inputFields == null){</span>
<span class="fc" id="L322">			InputMapper inputMapper = getInputMapper();</span>

<span class="fc" id="L324">			this.inputFields = updateNames(createInputFields(), inputMapper);</span>
		}

<span class="fc" id="L327">		return this.inputFields;</span>
	}

	@Override
	public List&lt;InputField&gt; getActiveFields(){

<span class="fc bfc" id="L333" title="All 2 branches covered.">		if(this.activeInputFields == null){</span>
<span class="fc" id="L334">			InputMapper inputMapper = getInputMapper();</span>

<span class="fc" id="L336">			this.activeInputFields = updateNames(createInputFields(MiningField.UsageType.ACTIVE), inputMapper);</span>
		}

<span class="fc" id="L339">		return this.activeInputFields;</span>
	}

	@Override
	public List&lt;TargetField&gt; getTargetFields(){

<span class="fc bfc" id="L345" title="All 2 branches covered.">		if(this.targetResultFields == null){</span>
<span class="fc" id="L346">			ResultMapper resultMapper = getResultMapper();</span>

<span class="fc" id="L348">			this.targetResultFields = updateNames(createTargetFields(), resultMapper);</span>
		}

<span class="fc" id="L351">		return this.targetResultFields;</span>
	}

	public TargetField getTargetField(){
<span class="fc" id="L355">		List&lt;TargetField&gt; targetFields = getTargetFields();</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">		if(targetFields.size() != 1){</span>
<span class="fc" id="L358">			throw createMiningSchemaException(&quot;Expected 1 target field, got &quot; + targetFields.size() + &quot; target fields&quot;);</span>
		}

<span class="fc" id="L361">		TargetField targetField = targetFields.get(0);</span>

<span class="fc" id="L363">		return targetField;</span>
	}

	public FieldName getTargetName(){
<span class="fc" id="L367">		TargetField targetField = getTargetField();</span>

<span class="fc" id="L369">		return targetField.getFieldName();</span>
	}

	TargetField findTargetField(FieldName name){
<span class="fc" id="L373">		List&lt;TargetField&gt; targetFields = getTargetFields();</span>

<span class="pc bpc" id="L375" title="1 of 2 branches missed.">		for(TargetField targetField : targetFields){</span>

<span class="pc bpc" id="L377" title="1 of 2 branches missed.">			if(Objects.equals(targetField.getFieldName(), name)){</span>
<span class="fc" id="L378">				return targetField;</span>
			}
<span class="nc" id="L380">		}</span>

<span class="nc" id="L382">		return null;</span>
	}

	@Override
	public List&lt;OutputField&gt; getOutputFields(){

<span class="fc bfc" id="L388" title="All 2 branches covered.">		if(this.outputResultFields == null){</span>
<span class="fc" id="L389">			ResultMapper resultMapper = getResultMapper();</span>

<span class="fc" id="L391">			this.outputResultFields = updateNames(createOutputFields(), resultMapper);</span>
		}

<span class="fc" id="L394">		return this.outputResultFields;</span>
	}

	/**
	 * &lt;p&gt;
	 * Indicates if this model evaluator provides the specified result feature.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * A result feature is first and foremost manifested through output fields.
	 * However, selected result features may make a secondary manifestation through a target field.
	 * &lt;/p&gt;
	 *
	 * @see org.dmg.pmml.OutputField#getResultFeature()
	 */
	public boolean hasResultFeature(org.dmg.pmml.ResultFeature resultFeature){
<span class="fc" id="L410">		Set&lt;org.dmg.pmml.ResultFeature&gt; resultFeatures = getResultFeatures();</span>

<span class="fc" id="L412">		return resultFeatures.contains(resultFeature);</span>
	}

	public Set&lt;org.dmg.pmml.ResultFeature&gt; getResultFeatures(){

<span class="fc bfc" id="L417" title="All 2 branches covered.">		if(this.resultFeatures == null){</span>
<span class="fc" id="L418">			this.resultFeatures = collectResultFeatures();</span>
		}

<span class="fc" id="L421">		return this.resultFeatures;</span>
	}

	protected EvaluationException createMiningSchemaException(String message){
<span class="fc" id="L425">		M model = getModel();</span>

<span class="fc" id="L427">		MiningSchema miningSchema = model.getMiningSchema();</span>

<span class="fc" id="L429">		return new EvaluationException(message, miningSchema);</span>
	}

	@Override
	public ModelEvaluator&lt;M&gt; verify(){
<span class="fc" id="L434">		M model = getModel();</span>

<span class="fc" id="L436">		ModelVerification modelVerification = model.getModelVerification();</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">		if(modelVerification == null){</span>
<span class="fc" id="L438">			return this;</span>
		}

<span class="fc" id="L441">		VerificationBatch batch = CacheUtil.getValue(modelVerification, ModelEvaluator.batchCache);</span>

<span class="fc" id="L443">		List&lt;? extends Map&lt;FieldName, ?&gt;&gt; records = batch.getRecords();</span>

<span class="fc" id="L445">		List&lt;InputField&gt; inputFields = getInputFields();</span>

<span class="fc bfc" id="L447" title="All 2 branches covered.">		if(this instanceof HasGroupFields){</span>
<span class="fc" id="L448">			HasGroupFields hasGroupFields = (HasGroupFields)this;</span>

<span class="fc" id="L450">			records = EvaluatorUtil.groupRows(hasGroupFields, records);</span>
		}

<span class="fc" id="L453">		List&lt;TargetField&gt; targetFields = getTargetFields();</span>
<span class="fc" id="L454">		List&lt;OutputField&gt; outputFields = getOutputFields();</span>

<span class="fc" id="L456">		SetView&lt;FieldName&gt; intersection = Sets.intersection(batch.keySet(), new LinkedHashSet&lt;&gt;(Lists.transform(outputFields, OutputField::getFieldName)));</span>

<span class="fc" id="L458">		boolean disjoint = intersection.isEmpty();</span>

<span class="fc bfc" id="L460" title="All 2 branches covered.">		for(Map&lt;FieldName, ?&gt; record : records){</span>
<span class="fc" id="L461">			Map&lt;FieldName, Object&gt; arguments = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L463" title="All 2 branches covered.">			for(InputField inputField : inputFields){</span>
<span class="fc" id="L464">				FieldName name = inputField.getFieldName();</span>

<span class="fc" id="L466">				FieldValue value = inputField.prepare(record.get(name));</span>

<span class="fc" id="L468">				arguments.put(name, value);</span>
<span class="fc" id="L469">			}</span>

<span class="fc" id="L471">			ModelEvaluationContext context = createEvaluationContext();</span>
<span class="fc" id="L472">			context.setArguments(arguments);</span>

<span class="fc" id="L474">			Map&lt;FieldName, ?&gt; results = evaluateInternal(context);</span>

			// &quot;If there exist VerificationField elements that refer to OutputField elements,
			// then any VerificationField element that refers to a MiningField element whose &quot;usageType=target&quot; should be ignored,
			// because they are considered to represent a dependent variable from the training data set, not an expected output&quot;
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">			if(!disjoint){</span>

<span class="fc bfc" id="L481" title="All 2 branches covered.">				for(OutputField outputField : outputFields){</span>
<span class="fc" id="L482">					FieldName name = outputField.getFieldName();</span>

<span class="fc" id="L484">					VerificationField verificationField = batch.get(name);</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">					if(verificationField == null){</span>
<span class="nc" id="L486">						continue;</span>
					}

<span class="fc" id="L489">					verify(record.get(name), results.get(name), verificationField.getPrecision(), verificationField.getZeroThreshold());</span>
<span class="fc" id="L490">				}</span>
			} else

			// &quot;If there are no such VerificationField elements,
			// then any VerificationField element that refers to a MiningField element whose &quot;usageType=target&quot; should be considered to represent an expected output&quot;
			{
<span class="nc bnc" id="L496" title="All 2 branches missed.">				for(TargetField targetField : targetFields){</span>
<span class="nc" id="L497">					FieldName name = targetField.getFieldName();</span>

<span class="nc" id="L499">					VerificationField verificationField = batch.get(name);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">					if(verificationField == null){</span>
<span class="nc" id="L501">						continue;</span>
					}

<span class="nc" id="L504">					verify(record.get(name), EvaluatorUtil.decode(results.get(name)), verificationField.getPrecision(), verificationField.getZeroThreshold());</span>
<span class="nc" id="L505">				}</span>
			}
<span class="fc" id="L507">		}</span>

<span class="fc" id="L509">		return this;</span>
	}

	private void verify(Object expected, Object actual, double precision, double zeroThreshold){

<span class="fc bfc" id="L514" title="All 2 branches covered.">		if(expected == null){</span>
<span class="fc" id="L515">			return;</span>
		} // End if

<span class="fc bfc" id="L518" title="All 2 branches covered.">		if(actual instanceof Collection){</span>
			// Ignored
		} else

		{
<span class="fc" id="L523">			DataType dataType = TypeUtil.getDataType(actual);</span>

<span class="fc" id="L525">			expected = TypeUtil.parseOrCast(dataType, expected);</span>
		}

<span class="fc" id="L528">		boolean acceptable = VerificationUtil.acceptable(expected, actual, precision, zeroThreshold);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">		if(!acceptable){</span>
<span class="nc" id="L530">			throw new EvaluationException(&quot;Values &quot; + PMMLException.formatValue(expected) + &quot; and &quot; + PMMLException.formatValue(actual) + &quot; do not match&quot;);</span>
		}
<span class="fc" id="L532">	}</span>

	public ModelEvaluationContext createEvaluationContext(){
<span class="fc" id="L535">		return new ModelEvaluationContext(this);</span>
	}

	@Override
	public Map&lt;FieldName, ?&gt; evaluate(Map&lt;FieldName, ?&gt; arguments){
<span class="fc" id="L540">		InputMapper inputMapper = getInputMapper();</span>
<span class="fc" id="L541">		ResultMapper resultMapper = getResultMapper();</span>

<span class="fc" id="L543">		ModelEvaluationContext context = createEvaluationContext();</span>

<span class="fc bfc" id="L545" title="All 2 branches covered.">		if(inputMapper != null){</span>
<span class="fc" id="L546">			Map&lt;FieldName, Object&gt; remappedArguments = new AbstractMap&lt;FieldName, Object&gt;(){</span>

				@Override
				public Object get(Object key){
<span class="fc" id="L550">					return arguments.get(inputMapper.apply((FieldName)key));</span>
				}

				@Override
				public Set&lt;Map.Entry&lt;FieldName, Object&gt;&gt; entrySet(){
<span class="nc" id="L555">					throw new UnsupportedOperationException();</span>
				}
			};

<span class="fc" id="L559">			context.setArguments(remappedArguments);</span>
<span class="fc" id="L560">		} else</span>

		{
<span class="fc" id="L563">			context.setArguments(arguments);</span>
		}

<span class="fc" id="L566">		Map&lt;FieldName, ?&gt; results = evaluateInternal(context);</span>

<span class="fc bfc" id="L568" title="All 2 branches covered.">		if(results instanceof OutputMap){</span>
<span class="fc" id="L569">			OutputMap outputMap = (OutputMap)results;</span>

<span class="fc" id="L571">			outputMap.clearPrivate();</span>
		} // End if

<span class="fc bfc" id="L574" title="All 2 branches covered.">		if(resultMapper != null){</span>

<span class="pc bpc" id="L576" title="1 of 2 branches missed.">			if(results.size() == 0){</span>
<span class="nc" id="L577">				return results;</span>
			} else

<span class="pc bpc" id="L580" title="1 of 2 branches missed.">			if(results.size() == 1){</span>
<span class="nc" id="L581">				Map.Entry&lt;FieldName, ?&gt; entry = Iterables.getOnlyElement(results.entrySet());</span>

<span class="nc" id="L583">				return Collections.singletonMap(resultMapper.apply(entry.getKey()), entry.getValue());</span>
			}

<span class="fc" id="L586">			Map&lt;FieldName, Object&gt; remappedResults = new LinkedHashMap&lt;&gt;(2 * results.size());</span>

<span class="fc" id="L588">			Collection&lt;? extends Map.Entry&lt;FieldName, ?&gt;&gt; entries = results.entrySet();</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">			for(Map.Entry&lt;FieldName, ?&gt; entry : entries){</span>
<span class="fc" id="L590">				remappedResults.put(resultMapper.apply(entry.getKey()), entry.getValue());</span>
<span class="fc" id="L591">			}</span>

<span class="fc" id="L593">			return remappedResults;</span>
		}

<span class="fc" id="L596">		return results;</span>
	}

	public Map&lt;FieldName, ?&gt; evaluateInternal(ModelEvaluationContext context){
<span class="fc" id="L600">		M model = getModel();</span>

<span class="pc bpc" id="L602" title="1 of 2 branches missed.">		if(!model.isScorable()){</span>
<span class="nc" id="L603">			throw new EvaluationException(&quot;Model is not scorable&quot;, model);</span>
		}

		ValueFactory&lt;?&gt; valueFactory;

<span class="fc" id="L608">		MathContext mathContext = model.getMathContext();</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">		switch(mathContext){</span>
			case FLOAT:
			case DOUBLE:
<span class="fc" id="L612">				valueFactory = ensureValueFactory();</span>
<span class="fc" id="L613">				break;</span>
			default:
<span class="nc" id="L615">				throw new UnsupportedAttributeException(model, mathContext);</span>
		}

		Map&lt;FieldName, ?&gt; predictions;

<span class="fc" id="L620">		MiningFunction miningFunction = model.getMiningFunction();</span>
<span class="pc bpc" id="L621" title="3 of 8 branches missed.">		switch(miningFunction){</span>
			case REGRESSION:
<span class="fc" id="L623">				predictions = evaluateRegression(valueFactory, context);</span>
<span class="fc" id="L624">				break;</span>
			case CLASSIFICATION:
<span class="fc" id="L626">				predictions = evaluateClassification(valueFactory, context);</span>
<span class="fc" id="L627">				break;</span>
			case CLUSTERING:
<span class="fc" id="L629">				predictions = evaluateClustering(valueFactory, context);</span>
<span class="fc" id="L630">				break;</span>
			case ASSOCIATION_RULES:
<span class="fc" id="L632">				predictions = evaluateAssociationRules(valueFactory, context);</span>
<span class="fc" id="L633">				break;</span>
			case SEQUENCES:
<span class="nc" id="L635">				predictions = evaluateSequences(valueFactory, context);</span>
<span class="nc" id="L636">				break;</span>
			case TIME_SERIES:
<span class="nc" id="L638">				predictions = evaluateTimeSeries(valueFactory, context);</span>
<span class="nc" id="L639">				break;</span>
			case MIXED:
<span class="fc" id="L641">				predictions = evaluateMixed(valueFactory, context);</span>
<span class="fc" id="L642">				break;</span>
			default:
<span class="nc" id="L644">				throw new UnsupportedAttributeException(model, miningFunction);</span>
		}

<span class="fc" id="L647">		return OutputUtil.evaluate(predictions, context);</span>
	}

	protected &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateRegression(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L651">		return evaluateDefault();</span>
	}

	protected &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateClassification(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L655">		return evaluateDefault();</span>
	}

	protected &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateClustering(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L659">		return evaluateDefault();</span>
	}

	protected &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateAssociationRules(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L663">		return evaluateDefault();</span>
	}

	protected &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateSequences(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L667">		return evaluateDefault();</span>
	}

	protected &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateTimeSeries(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L671">		return evaluateDefault();</span>
	}

	protected &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateMixed(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L675">		return evaluateDefault();</span>
	}

	private &lt;V extends Number&gt; Map&lt;FieldName, ?&gt; evaluateDefault(){
<span class="nc" id="L679">		Model model = getModel();</span>

<span class="nc" id="L681">		MiningFunction miningFunction = model.getMiningFunction();</span>

<span class="nc" id="L683">		throw new InvalidAttributeException(model, miningFunction);</span>
	}

	protected &lt;V extends Number&gt; Classification&lt;V&gt; createClassification(ValueMap&lt;String, V&gt; values){

<span class="fc bfc" id="L688" title="All 4 branches covered.">		if(hasResultFeature(org.dmg.pmml.ResultFeature.PROBABILITY) || hasResultFeature(org.dmg.pmml.ResultFeature.RESIDUAL)){</span>
<span class="fc" id="L689">			return new ProbabilityDistribution&lt;V&gt;(values);</span>
		} else

<span class="pc bpc" id="L692" title="1 of 2 branches missed.">		if(hasResultFeature(org.dmg.pmml.ResultFeature.CONFIDENCE)){</span>
<span class="nc" id="L693">			return new ConfidenceDistribution&lt;V&gt;(values);</span>
		} else

		{
<span class="fc" id="L697">			return new Classification&lt;V&gt;(Classification.Type.VOTE, values);</span>
		}
	}

	protected Field&lt;?&gt; resolveField(FieldName name){
<span class="fc" id="L702">		Field&lt;?&gt; result = getDataField(name);</span>

<span class="fc bfc" id="L704" title="All 2 branches covered.">		if(result == null){</span>
<span class="fc" id="L705">			result = resolveDerivedField(name);</span>
		}

<span class="fc" id="L708">		return result;</span>
	}

	protected DerivedField resolveDerivedField(FieldName name){
<span class="fc" id="L712">		DerivedField result = getDerivedField(name);</span>

<span class="pc bpc" id="L714" title="1 of 2 branches missed.">		if(result == null){</span>
<span class="fc" id="L715">			result = getLocalDerivedField(name);</span>
		}

<span class="fc" id="L718">		return result;</span>
	}

	protected boolean assessParentCompatibility(){
<span class="fc" id="L722">		List&lt;InputField&gt; inputFields = getInputFields();</span>

<span class="fc bfc" id="L724" title="All 2 branches covered.">		for(InputField inputField : inputFields){</span>
<span class="fc" id="L725">			Field&lt;?&gt; field = inputField.getField();</span>
<span class="fc" id="L726">			MiningField miningField = inputField.getMiningField();</span>

<span class="pc bpc" id="L728" title="1 of 2 branches missed.">			if(!(field instanceof DataField)){</span>
<span class="nc" id="L729">				continue;</span>
			} // End if

<span class="fc bfc" id="L732" title="All 2 branches covered.">			if(!InputFieldUtil.isDefault(field, miningField)){</span>
<span class="fc" id="L733">				return false;</span>
			}
<span class="fc" id="L735">		}</span>

<span class="fc" id="L737">		return true;</span>
	}

	protected boolean assessPurity(){
<span class="fc" id="L741">		List&lt;InputField&gt; inputFields = getInputFields();</span>

<span class="fc bfc" id="L743" title="All 2 branches covered.">		for(InputField inputField : inputFields){</span>
<span class="fc" id="L744">			Field&lt;?&gt; field = inputField.getField();</span>
<span class="fc" id="L745">			MiningField miningField = inputField.getMiningField();</span>

<span class="fc bfc" id="L747" title="All 2 branches covered.">			if(!InputFieldUtil.isDefault(field, miningField)){</span>
<span class="fc" id="L748">				return false;</span>
			}
<span class="fc" id="L750">		}</span>

<span class="pc bpc" id="L752" title="1 of 4 branches missed.">		return this.localDerivedFields.isEmpty() &amp;&amp; this.outputFields.isEmpty();</span>
	}

	protected List&lt;InputField&gt; createInputFields(){
<span class="fc" id="L756">		List&lt;InputField&gt; inputFields = getActiveFields();</span>

<span class="fc" id="L758">		List&lt;OutputField&gt; outputFields = getOutputFields();</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">		if(outputFields.size() &gt; 0){</span>
<span class="fc" id="L760">			List&lt;ResidualInputField&gt; residualInputFields = null;</span>

<span class="fc bfc" id="L762" title="All 2 branches covered.">			for(OutputField outputField : outputFields){</span>
<span class="fc" id="L763">				org.dmg.pmml.OutputField pmmlOutputField = outputField.getField();</span>

<span class="fc bfc" id="L765" title="All 2 branches covered.">				if(!(org.dmg.pmml.ResultFeature.RESIDUAL).equals(pmmlOutputField.getResultFeature())){</span>
<span class="fc" id="L766">					continue;</span>
				}

<span class="fc" id="L769">				int depth = outputField.getDepth();</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">				if(depth &gt; 0){</span>
<span class="nc" id="L771">					throw new UnsupportedElementException(pmmlOutputField);</span>
				}

<span class="fc" id="L774">				FieldName targetName = pmmlOutputField.getTargetField();</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">				if(targetName == null){</span>
<span class="fc" id="L776">					targetName = getTargetName();</span>
				}

<span class="fc" id="L779">				DataField dataField = getDataField(targetName);</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">				if(dataField == null){</span>
<span class="nc" id="L781">					throw new MissingFieldException(targetName, pmmlOutputField);</span>
				}

<span class="fc" id="L784">				MiningField miningField = getMiningField(targetName);</span>
<span class="pc bpc" id="L785" title="1 of 2 branches missed.">				if(miningField == null){</span>
<span class="nc" id="L786">					throw new InvisibleFieldException(targetName, pmmlOutputField);</span>
				}

<span class="fc" id="L789">				ResidualInputField residualInputField = new ResidualInputField(dataField, miningField);</span>

<span class="pc bpc" id="L791" title="1 of 2 branches missed.">				if(residualInputFields == null){</span>
<span class="fc" id="L792">					residualInputFields = new ArrayList&lt;&gt;();</span>
				}

<span class="fc" id="L795">				residualInputFields.add(residualInputField);</span>
<span class="fc" id="L796">			}</span>

<span class="pc bpc" id="L798" title="1 of 4 branches missed.">			if(residualInputFields != null &amp;&amp; residualInputFields.size() &gt; 0){</span>
<span class="fc" id="L799">				inputFields = ImmutableList.copyOf(Iterables.concat(inputFields, residualInputFields));</span>
			}
		}

<span class="fc" id="L803">		return inputFields;</span>
	}

	protected List&lt;InputField&gt; createInputFields(MiningField.UsageType usageType){
<span class="fc" id="L807">		M model = getModel();</span>

<span class="fc" id="L809">		MiningSchema miningSchema = model.getMiningSchema();</span>

<span class="fc" id="L811">		List&lt;InputField&gt; inputFields = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L813" title="1 of 2 branches missed.">		if(miningSchema.hasMiningFields()){</span>
<span class="fc" id="L814">			List&lt;MiningField&gt; miningFields = miningSchema.getMiningFields();</span>

<span class="fc bfc" id="L816" title="All 2 branches covered.">			for(MiningField miningField : miningFields){</span>
<span class="fc" id="L817">				FieldName name = miningField.getName();</span>

<span class="fc bfc" id="L819" title="All 2 branches covered.">				if(!(miningField.getUsageType()).equals(usageType)){</span>
<span class="fc" id="L820">					continue;</span>
				}

<span class="fc" id="L823">				Field&lt;?&gt; field = getDataField(name);</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">				if(field == null){</span>
<span class="fc" id="L825">					field = new VariableField(name);</span>
				}

<span class="fc" id="L828">				InputField inputField = new InputField(field, miningField);</span>

<span class="fc" id="L830">				inputFields.add(inputField);</span>
<span class="fc" id="L831">			}</span>
		}

<span class="fc" id="L834">		return ImmutableList.copyOf(inputFields);</span>
	}

	protected List&lt;TargetField&gt; createTargetFields(){
<span class="fc" id="L838">		M model = getModel();</span>

<span class="fc" id="L840">		MiningSchema miningSchema = model.getMiningSchema();</span>

<span class="fc" id="L842">		List&lt;TargetField&gt; targetFields = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L844" title="All 2 branches covered.">		if(miningSchema.hasMiningFields()){</span>
<span class="fc" id="L845">			List&lt;MiningField&gt; miningFields = miningSchema.getMiningFields();</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">			for(MiningField miningField : miningFields){</span>
<span class="fc" id="L848">				FieldName name = miningField.getName();</span>

<span class="fc" id="L850">				MiningField.UsageType usageType = miningField.getUsageType();</span>
<span class="pc bfc" id="L851" title="All 2 branches covered.">				switch(usageType){</span>
					case TARGET:
					case PREDICTED:
<span class="fc" id="L854">						break;</span>
					default:
<span class="fc" id="L856">						continue;</span>
				}

<span class="fc" id="L859">				DataField dataField = getDataField(name);</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">				if(dataField == null){</span>
<span class="nc" id="L861">					throw new MissingFieldException(name, miningField);</span>
				}

<span class="fc" id="L864">				Target target = getTarget(name);</span>

<span class="fc" id="L866">				TargetField targetField = new TargetField(dataField, miningField, target);</span>

<span class="fc" id="L868">				targetFields.add(targetField);</span>
<span class="fc" id="L869">			}</span>
		}

		synthesis:
<span class="fc bfc" id="L873" title="All 2 branches covered.">		if(targetFields.isEmpty()){</span>
<span class="fc" id="L874">			DataField dataField = getDataField();</span>

<span class="fc bfc" id="L876" title="All 2 branches covered.">			if(dataField == null){</span>
<span class="fc" id="L877">				break synthesis;</span>
			}

<span class="fc" id="L880">			Target target = getTarget(dataField.getName());</span>

<span class="fc" id="L882">			TargetField targetField = new TargetField(dataField, null, target);</span>

<span class="fc" id="L884">			targetFields.add(targetField);</span>
		}

<span class="fc" id="L887">		return ImmutableList.copyOf(targetFields);</span>
	}

	protected List&lt;OutputField&gt; createOutputFields(){
<span class="fc" id="L891">		M model = getModel();</span>

<span class="fc" id="L893">		Output output = model.getOutput();</span>

<span class="fc" id="L895">		List&lt;OutputField&gt; resultFields = new ArrayList&lt;&gt;();</span>

<span class="pc bpc" id="L897" title="1 of 4 branches missed.">		if(output != null &amp;&amp; output.hasOutputFields()){</span>
<span class="fc" id="L898">			List&lt;org.dmg.pmml.OutputField&gt; outputFields = output.getOutputFields();</span>

<span class="fc" id="L900">			Predicate&lt;org.dmg.pmml.OutputField&gt; outputFilter = ensureOutputFilter();</span>

			outputFields:
<span class="fc bfc" id="L903" title="All 2 branches covered.">			for(org.dmg.pmml.OutputField outputField : outputFields){</span>

<span class="fc bfc" id="L905" title="All 2 branches covered.">				if(outputFilter.test(outputField)){</span>
<span class="fc" id="L906">					OutputField resultField = new OutputField(outputField);</span>

<span class="fc" id="L908">					resultFields.add(resultField);</span>
				}
<span class="fc" id="L910">			}</span>
		}

<span class="fc" id="L913">		return ImmutableList.copyOf(resultFields);</span>
	}

	protected Set&lt;org.dmg.pmml.ResultFeature&gt; collectResultFeatures(){
<span class="fc" id="L917">		M model = getModel();</span>

<span class="fc" id="L919">		Output output = model.getOutput();</span>

<span class="fc" id="L921">		Set&lt;org.dmg.pmml.ResultFeature&gt; resultFeatures = EnumSet.noneOf(org.dmg.pmml.ResultFeature.class);</span>

<span class="pc bpc" id="L923" title="1 of 4 branches missed.">		if(output != null &amp;&amp; output.hasOutputFields()){</span>
<span class="fc" id="L924">			List&lt;org.dmg.pmml.OutputField&gt; outputFields = output.getOutputFields();</span>

<span class="fc bfc" id="L926" title="All 2 branches covered.">			for(org.dmg.pmml.OutputField outputField : outputFields){</span>
<span class="fc" id="L927">				resultFeatures.add(outputField.getResultFeature());</span>
<span class="fc" id="L928">			}</span>
		}

<span class="fc" id="L931">		return Sets.immutableEnumSet(resultFeatures);</span>
	}

	private void resetInputFields(){
<span class="fc" id="L935">		this.inputFields = null;</span>
<span class="fc" id="L936">		this.activeInputFields = null;</span>
<span class="fc" id="L937">	}</span>

	private void resetResultFields(){
<span class="fc" id="L940">		this.targetResultFields = null;</span>
<span class="fc" id="L941">		this.outputResultFields = null;</span>

<span class="fc" id="L943">		this.resultFeatures = null;</span>
<span class="fc" id="L944">	}</span>

	public &lt;V&gt; V getValue(LoadingCache&lt;M, V&gt; cache){
<span class="fc" id="L947">		M model = getModel();</span>

<span class="fc" id="L949">		return CacheUtil.getValue(model, cache);</span>
	}

	public &lt;V&gt; V getValue(Cache&lt;M, V&gt; cache, Callable&lt;? extends V&gt; loader){
<span class="fc" id="L953">		M model = getModel();</span>

<span class="fc" id="L955">		return CacheUtil.getValue(model, cache, loader);</span>
	}

	protected Configuration ensureConfiguration(){
<span class="fc" id="L959">		Configuration configuration = getConfiguration();</span>

<span class="pc bpc" id="L961" title="1 of 2 branches missed.">		if(this.configuration == null){</span>
<span class="nc" id="L962">			throw new IllegalStateException();</span>
		}

<span class="fc" id="L965">		return this.configuration;</span>
	}

	protected ModelEvaluatorFactory ensureModelEvaluatorFactory(){
<span class="nc" id="L969">		Configuration configuration = ensureConfiguration();</span>

<span class="nc" id="L971">		return configuration.getModelEvaluatorFactory();</span>
	}

	protected ValueFactoryFactory ensureValueFactoryFactory(){
<span class="fc" id="L975">		Configuration configuration = ensureConfiguration();</span>

<span class="fc" id="L977">		return configuration.getValueFactoryFactory();</span>
	}

	protected Predicate&lt;org.dmg.pmml.OutputField&gt; ensureOutputFilter(){
<span class="fc" id="L981">		Configuration configuration = ensureConfiguration();</span>

<span class="fc" id="L983">		return configuration.getOutputFilter();</span>
	}

	protected ValueFactory&lt;?&gt; ensureValueFactory(){
<span class="fc" id="L987">		ValueFactory&lt;?&gt; valueFactory = getValueFactory();</span>

<span class="fc bfc" id="L989" title="All 2 branches covered.">		if(valueFactory == null){</span>
<span class="fc" id="L990">			ValueFactoryFactory valueFactoryFactory = ensureValueFactoryFactory();</span>

<span class="fc" id="L992">			MathContext mathContext = getMathContext();</span>

<span class="fc" id="L994">			valueFactory = valueFactoryFactory.newValueFactory(mathContext);</span>

<span class="fc" id="L996">			setValueFactory(valueFactory);</span>
		}

<span class="fc" id="L999">		return valueFactory;</span>
	}

	@Override
	public PMML getPMML(){
<span class="fc" id="L1004">		return this.pmml;</span>
	}

	private void setPMML(PMML pmml){
<span class="fc" id="L1008">		this.pmml = pmml;</span>
<span class="fc" id="L1009">	}</span>

	@Override
	public M getModel(){
<span class="fc" id="L1013">		return this.model;</span>
	}

	private void setModel(M model){
<span class="fc" id="L1017">		this.model = model;</span>
<span class="fc" id="L1018">	}</span>

	public Configuration getConfiguration(){
<span class="fc" id="L1021">		return this.configuration;</span>
	}

	private void setConfiguration(Configuration configuration){
<span class="fc" id="L1025">		this.configuration = configuration;</span>
<span class="fc" id="L1026">	}</span>

	public InputMapper getInputMapper(){
<span class="fc" id="L1029">		return this.inputMapper;</span>
	}

	void setInputMapper(InputMapper inputMapper){
<span class="fc" id="L1033">		this.inputMapper = inputMapper;</span>

<span class="fc" id="L1035">		resetInputFields();</span>
<span class="fc" id="L1036">	}</span>

	public ResultMapper getResultMapper(){
<span class="fc" id="L1039">		return this.resultMapper;</span>
	}

	void setResultMapper(ResultMapper resultMapper){
<span class="fc" id="L1043">		this.resultMapper = resultMapper;</span>

<span class="fc" id="L1045">		resetResultFields();</span>
<span class="fc" id="L1046">	}</span>

	private ValueFactory&lt;?&gt; getValueFactory(){
<span class="fc" id="L1049">		return this.valueFactory;</span>
	}

	private void setValueFactory(ValueFactory&lt;?&gt; valueFactory){
<span class="fc" id="L1053">		this.valueFactory = valueFactory;</span>
<span class="fc" id="L1054">	}</span>

	static
	private VerificationBatch parseModelVerification(ModelVerification modelVerification){
<span class="fc" id="L1058">		VerificationBatch result = new VerificationBatch();</span>

<span class="fc" id="L1060">		VerificationFields verificationFields = modelVerification.getVerificationFields();</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">		if(verificationFields == null){</span>
<span class="nc" id="L1062">			throw new MissingElementException(modelVerification, PMMLElements.MODELVERIFICATION_VERIFICATIONFIELDS);</span>
		}

<span class="fc bfc" id="L1065" title="All 2 branches covered.">		for(VerificationField verificationField : verificationFields){</span>
<span class="fc" id="L1066">			result.put(verificationField.getField(), verificationField);</span>
<span class="fc" id="L1067">		}</span>

<span class="fc" id="L1069">		InlineTable inlineTable = modelVerification.getInlineTable();</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">		if(inlineTable == null){</span>
<span class="nc" id="L1071">			throw new MissingElementException(modelVerification, PMMLElements.MODELVERIFICATION_INLINETABLE);</span>
		}

<span class="fc" id="L1074">		Table&lt;Integer, String, Object&gt; table = InlineTableUtil.getContent(inlineTable);</span>

<span class="fc" id="L1076">		List&lt;Map&lt;FieldName, Object&gt;&gt; records = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L1078">		Set&lt;Integer&gt; rowKeys = table.rowKeySet();</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">		for(Integer rowKey : rowKeys){</span>
<span class="fc" id="L1080">			Map&lt;String, Object&gt; row = table.row(rowKey);</span>

<span class="fc" id="L1082">			Map&lt;FieldName, Object&gt; record = new LinkedHashMap&lt;&gt;();</span>

<span class="fc bfc" id="L1084" title="All 2 branches covered.">			for(VerificationField verificationField : verificationFields){</span>
<span class="fc" id="L1085">				FieldName name = verificationField.getField();</span>
<span class="fc" id="L1086">				String column = verificationField.getColumn();</span>

<span class="fc bfc" id="L1088" title="All 2 branches covered.">				if(column == null){</span>
<span class="fc" id="L1089">					column = name.getValue();</span>
				} // End if

<span class="fc bfc" id="L1092" title="All 2 branches covered.">				if(!row.containsKey(column)){</span>
<span class="fc" id="L1093">					continue;</span>
				}

<span class="fc" id="L1096">				record.put(name, row.get(column));</span>
<span class="fc" id="L1097">			}</span>

<span class="fc" id="L1099">			records.add(record);</span>
<span class="fc" id="L1100">		}</span>

<span class="fc" id="L1102">		Integer recordCount = modelVerification.getRecordCount();</span>
<span class="pc bpc" id="L1103" title="3 of 4 branches missed.">		if(recordCount != null &amp;&amp; recordCount != records.size()){</span>
<span class="nc" id="L1104">			throw new InvalidElementException(modelVerification);</span>
		}

<span class="fc" id="L1107">		result.setRecords(records);</span>

<span class="fc" id="L1109">		return result;</span>
	}

	static
	private &lt;F extends ModelField&gt; List&lt;F&gt; updateNames(List&lt;F&gt; fields, java.util.function.Function&lt;FieldName, FieldName&gt; mapper){

<span class="fc bfc" id="L1115" title="All 2 branches covered.">		if(mapper == null){</span>
<span class="fc" id="L1116">			return fields;</span>
		}

<span class="fc bfc" id="L1119" title="All 2 branches covered.">		for(F field : fields){</span>
<span class="fc" id="L1120">			FieldName name = field.getFieldName();</span>

<span class="fc" id="L1122">			FieldName mappedName = mapper.apply(name);</span>
<span class="pc bpc" id="L1123" title="2 of 4 branches missed.">			if(mappedName != null &amp;&amp; !Objects.equals(mappedName, name)){</span>
<span class="fc" id="L1124">				field.setName(mappedName);</span>
			}
<span class="fc" id="L1126">		}</span>

<span class="fc" id="L1128">		return fields;</span>
	}

<span class="fc" id="L1131">	private static final DataField DEFAULT_TARGET_CONTINUOUS_FLOAT = new DataField(Evaluator.DEFAULT_TARGET_NAME, OpType.CONTINUOUS, DataType.FLOAT);</span>
<span class="fc" id="L1132">	private static final DataField DEFAULT_TARGET_CONTINUOUS_DOUBLE = new DataField(Evaluator.DEFAULT_TARGET_NAME, OpType.CONTINUOUS, DataType.DOUBLE);</span>
<span class="fc" id="L1133">	private static final DataField DEFAULT_TARGET_CATEGORICAL_STRING = new DataField(Evaluator.DEFAULT_TARGET_NAME, OpType.CATEGORICAL, DataType.STRING);</span>

<span class="fc" id="L1135">	private static final LoadingCache&lt;DataDictionary, Map&lt;FieldName, DataField&gt;&gt; dataFieldCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;DataDictionary, Map&lt;FieldName, DataField&gt;&gt;(){</span>

		@Override
		public Map&lt;FieldName, DataField&gt; load(DataDictionary dataDictionary){
<span class="fc" id="L1139">			return IndexableUtil.buildMap(dataDictionary.getDataFields());</span>
		}
	});

<span class="fc" id="L1143">	private static final LoadingCache&lt;TransformationDictionary, Map&lt;FieldName, DerivedField&gt;&gt; derivedFieldCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;TransformationDictionary, Map&lt;FieldName, DerivedField&gt;&gt;(){</span>

		@Override
		public Map&lt;FieldName, DerivedField&gt; load(TransformationDictionary transformationDictionary){
<span class="fc" id="L1147">			return IndexableUtil.buildMap(transformationDictionary.getDerivedFields());</span>
		}
	});

<span class="fc" id="L1151">	private static final LoadingCache&lt;TransformationDictionary, Map&lt;String, DefineFunction&gt;&gt; defineFunctionCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;TransformationDictionary, Map&lt;String, DefineFunction&gt;&gt;(){</span>

		@Override
		public Map&lt;String, DefineFunction&gt; load(TransformationDictionary transformationDictionary){
<span class="fc" id="L1155">			return IndexableUtil.buildMap(transformationDictionary.getDefineFunctions());</span>
		}
	});

<span class="fc" id="L1159">	private static final LoadingCache&lt;MiningSchema, Map&lt;FieldName, MiningField&gt;&gt; miningFieldCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;MiningSchema, Map&lt;FieldName, MiningField&gt;&gt;(){</span>

		@Override
		public Map&lt;FieldName, MiningField&gt; load(MiningSchema miningSchema){
<span class="fc" id="L1163">			return IndexableUtil.buildMap(miningSchema.getMiningFields());</span>
		}
	});

<span class="fc" id="L1167">	private static final LoadingCache&lt;LocalTransformations, Map&lt;FieldName, DerivedField&gt;&gt; localDerivedFieldCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;LocalTransformations, Map&lt;FieldName, DerivedField&gt;&gt;(){</span>

		@Override
		public Map&lt;FieldName, DerivedField&gt; load(LocalTransformations localTransformations){
<span class="fc" id="L1171">			return IndexableUtil.buildMap(localTransformations.getDerivedFields());</span>
		}
	});

<span class="fc" id="L1175">	private static final LoadingCache&lt;Targets, Map&lt;FieldName, Target&gt;&gt; targetCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;Targets, Map&lt;FieldName, Target&gt;&gt;(){</span>

		@Override
		public Map&lt;FieldName, Target&gt; load(Targets targets){
<span class="fc" id="L1179">			return IndexableUtil.buildMap(targets.getTargets(), true);</span>
		}
	});

<span class="fc" id="L1183">	private static final LoadingCache&lt;Output, Map&lt;FieldName, org.dmg.pmml.OutputField&gt;&gt; outputFieldCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;Output, Map&lt;FieldName, org.dmg.pmml.OutputField&gt;&gt;(){</span>

		@Override
		public Map&lt;FieldName, org.dmg.pmml.OutputField&gt; load(Output output){
<span class="fc" id="L1187">			return IndexableUtil.buildMap(output.getOutputFields());</span>
		}
	});

	static
<span class="fc" id="L1192">	private class VerificationBatch extends LinkedHashMap&lt;FieldName, VerificationField&gt; {</span>

<span class="fc" id="L1194">		private List&lt;Map&lt;FieldName, Object&gt;&gt; records = null;</span>


		public List&lt;Map&lt;FieldName, Object&gt;&gt; getRecords(){
<span class="fc" id="L1198">			return this.records;</span>
		}

		private void setRecords(List&lt;Map&lt;FieldName, Object&gt;&gt; records){
<span class="fc" id="L1202">			this.records = records;</span>
<span class="fc" id="L1203">		}</span>
	}

<span class="fc" id="L1206">	private static final LoadingCache&lt;ModelVerification, VerificationBatch&gt; batchCache = CacheUtil.buildLoadingCache(new CacheLoader&lt;ModelVerification, VerificationBatch&gt;(){</span>

		@Override
		public VerificationBatch load(ModelVerification modelVerification){
<span class="fc" id="L1210">			return parseModelVerification(modelVerification);</span>
		}
	});
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>