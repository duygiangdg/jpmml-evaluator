<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NearestNeighborModelEvaluator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMML class model evaluator code coverage</a> &gt; <a href="index.source.html" class="el_package">org.jpmml.evaluator.nearest_neighbor</a> &gt; <span class="el_source">NearestNeighborModelEvaluator.java</span></div><h1>NearestNeighborModelEvaluator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013 KNIME.com AG, Zurich, Switzerland
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.jpmml.evaluator.nearest_neighbor;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;

import com.google.common.base.Function;
import com.google.common.cache.Cache;
import com.google.common.collect.Collections2;
import com.google.common.collect.HashBasedTable;
import com.google.common.collect.ImmutableSortedSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.LinkedHashMultiset;
import com.google.common.collect.Maps;
import com.google.common.collect.Multiset;
import com.google.common.collect.Ordering;
import com.google.common.collect.Table;
import org.dmg.pmml.ComparisonMeasure;
import org.dmg.pmml.DataField;
import org.dmg.pmml.DataType;
import org.dmg.pmml.DerivedField;
import org.dmg.pmml.Distance;
import org.dmg.pmml.Field;
import org.dmg.pmml.FieldName;
import org.dmg.pmml.InlineTable;
import org.dmg.pmml.Measure;
import org.dmg.pmml.MiningField;
import org.dmg.pmml.MiningFunction;
import org.dmg.pmml.OpType;
import org.dmg.pmml.PMML;
import org.dmg.pmml.Similarity;
import org.dmg.pmml.nearest_neighbor.InstanceField;
import org.dmg.pmml.nearest_neighbor.InstanceFields;
import org.dmg.pmml.nearest_neighbor.KNNInput;
import org.dmg.pmml.nearest_neighbor.KNNInputs;
import org.dmg.pmml.nearest_neighbor.NearestNeighborModel;
import org.dmg.pmml.nearest_neighbor.TrainingInstances;
import org.jpmml.evaluator.AffinityDistribution;
import org.jpmml.evaluator.CacheUtil;
import org.jpmml.evaluator.Classification;
import org.jpmml.evaluator.EvaluationContext;
import org.jpmml.evaluator.ExpressionUtil;
import org.jpmml.evaluator.FieldUtil;
import org.jpmml.evaluator.FieldValue;
import org.jpmml.evaluator.FieldValueUtil;
import org.jpmml.evaluator.InlineTableUtil;
import org.jpmml.evaluator.InputFieldUtil;
import org.jpmml.evaluator.InvalidAttributeException;
import org.jpmml.evaluator.InvalidElementException;
import org.jpmml.evaluator.InvisibleFieldException;
import org.jpmml.evaluator.MeasureUtil;
import org.jpmml.evaluator.MissingAttributeException;
import org.jpmml.evaluator.MissingElementException;
import org.jpmml.evaluator.MissingFieldException;
import org.jpmml.evaluator.MissingValueException;
import org.jpmml.evaluator.ModelEvaluationContext;
import org.jpmml.evaluator.ModelEvaluator;
import org.jpmml.evaluator.PMMLAttributes;
import org.jpmml.evaluator.PMMLElements;
import org.jpmml.evaluator.PMMLUtil;
import org.jpmml.evaluator.TargetField;
import org.jpmml.evaluator.TypeInfo;
import org.jpmml.evaluator.TypeInfos;
import org.jpmml.evaluator.TypeUtil;
import org.jpmml.evaluator.UnsupportedAttributeException;
import org.jpmml.evaluator.UnsupportedElementException;
import org.jpmml.evaluator.Value;
import org.jpmml.evaluator.ValueAggregator;
import org.jpmml.evaluator.ValueFactory;
import org.jpmml.evaluator.ValueMap;
import org.jpmml.evaluator.VoteAggregator;
import org.jpmml.model.visitors.FieldReferenceFinder;

public class NearestNeighborModelEvaluator extends ModelEvaluator&lt;NearestNeighborModel&gt; {

<span class="fc" id="L110">	transient</span>
	private Table&lt;Integer, FieldName, FieldValue&gt; trainingInstances = null;

<span class="fc" id="L113">	transient</span>
	private Map&lt;Integer, BitSet&gt; instanceFlags = null;

<span class="fc" id="L116">	transient</span>
	private Map&lt;Integer, List&lt;FieldValue&gt;&gt; instanceValues = null;


	public NearestNeighborModelEvaluator(PMML pmml){
<span class="nc" id="L121">		this(pmml, PMMLUtil.findModel(pmml, NearestNeighborModel.class));</span>
<span class="nc" id="L122">	}</span>

	public NearestNeighborModelEvaluator(PMML pmml, NearestNeighborModel nearestNeighborModel){
<span class="fc" id="L125">		super(pmml, nearestNeighborModel);</span>

<span class="fc" id="L127">		ComparisonMeasure comparisoonMeasure = nearestNeighborModel.getComparisonMeasure();</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">		if(comparisoonMeasure == null){</span>
<span class="nc" id="L129">			throw new MissingElementException(nearestNeighborModel, PMMLElements.NEARESTNEIGHBORMODEL_COMPARISONMEASURE);</span>
		}

<span class="fc" id="L132">		TrainingInstances trainingInstances = nearestNeighborModel.getTrainingInstances();</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">		if(trainingInstances == null){</span>
<span class="nc" id="L134">			throw new MissingElementException(nearestNeighborModel, PMMLElements.NEARESTNEIGHBORMODEL_TRAININGINSTANCES);</span>
		}

<span class="fc" id="L137">		InstanceFields instanceFields = trainingInstances.getInstanceFields();</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">		if(instanceFields == null){</span>
<span class="nc" id="L139">			throw new MissingElementException(trainingInstances, PMMLElements.TRAININGINSTANCES_INSTANCEFIELDS);</span>
		} // End if

<span class="pc bpc" id="L142" title="1 of 2 branches missed.">		if(!instanceFields.hasInstanceFields()){</span>
<span class="nc" id="L143">			throw new MissingElementException(instanceFields, PMMLElements.INSTANCEFIELDS_INSTANCEFIELDS);</span>
		}

<span class="fc" id="L146">		KNNInputs knnInputs = nearestNeighborModel.getKNNInputs();</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">		if(knnInputs == null){</span>
<span class="nc" id="L148">			throw new MissingElementException(nearestNeighborModel, PMMLElements.NEARESTNEIGHBORMODEL_KNNINPUTS);</span>
		} // End if

<span class="pc bpc" id="L151" title="1 of 2 branches missed.">		if(!knnInputs.hasKNNInputs()){</span>
<span class="nc" id="L152">			throw new MissingElementException(knnInputs, PMMLElements.KNNINPUTS_KNNINPUTS);</span>
		}
<span class="fc" id="L154">	}</span>

	@Override
	public String getSummary(){
<span class="nc" id="L158">		return &quot;k-Nearest neighbors model&quot;;</span>
	}

	@Override
	protected DataField getDataField(){
<span class="fc" id="L163">		MiningFunction miningFunction = getMiningFunction();</span>

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">		switch(miningFunction){</span>
			case REGRESSION:
			case CLASSIFICATION:
			case MIXED:
<span class="nc" id="L169">				return null;</span>
			default:
<span class="fc" id="L171">				return super.getDataField();</span>
		}
	}

	@Override
	protected &lt;V extends Number&gt; Map&lt;FieldName, AffinityDistribution&lt;V&gt;&gt; evaluateRegression(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="nc" id="L177">		return evaluateMixed(valueFactory, context);</span>
	}

	@Override
	protected &lt;V extends Number&gt; Map&lt;FieldName, AffinityDistribution&lt;V&gt;&gt; evaluateClassification(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="fc" id="L182">		return evaluateMixed(valueFactory, context);</span>
	}

	@Override
	protected &lt;V extends Number&gt; Map&lt;FieldName, AffinityDistribution&lt;V&gt;&gt; evaluateMixed(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="fc" id="L187">		NearestNeighborModel nearestNeighborModel = getModel();</span>

<span class="fc" id="L189">		Table&lt;Integer, FieldName, FieldValue&gt; table = getTrainingInstances();</span>

<span class="fc" id="L191">		List&lt;InstanceResult&lt;V&gt;&gt; instanceResults = evaluateInstanceRows(valueFactory, context);</span>

<span class="fc" id="L193">		Ordering&lt;InstanceResult&lt;V&gt;&gt; ordering = (Ordering.natural()).reverse();</span>

<span class="fc" id="L195">		List&lt;InstanceResult&lt;V&gt;&gt; nearestInstanceResults = ordering.sortedCopy(instanceResults);</span>

<span class="fc" id="L197">		int numberOfNeighbors = nearestNeighborModel.getNumberOfNeighbors();</span>

<span class="fc" id="L199">		nearestInstanceResults = nearestInstanceResults.subList(0, numberOfNeighbors);</span>

<span class="fc" id="L201">		Function&lt;Integer, String&gt; function = new Function&lt;Integer, String&gt;(){</span>

			@Override
			public String apply(Integer row){
<span class="fc" id="L205">				return row.toString();</span>
			}
		};

<span class="fc" id="L209">		FieldName instanceIdVariable = nearestNeighborModel.getInstanceIdVariable();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">		if(instanceIdVariable != null){</span>
<span class="nc" id="L211">			function = createIdentifierResolver(instanceIdVariable, table);</span>
		}

<span class="fc" id="L214">		Map&lt;FieldName, AffinityDistribution&lt;V&gt;&gt; results = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L216">		List&lt;TargetField&gt; targetFields = getTargetFields();</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">		for(TargetField targetField : targetFields){</span>
<span class="fc" id="L218">			FieldName name = targetField.getFieldName();</span>

			Object value;

<span class="fc" id="L222">			OpType opType = targetField.getOpType();</span>
<span class="pc bpc" id="L223" title="1 of 3 branches missed.">			switch(opType){</span>
				case CONTINUOUS:
<span class="fc" id="L225">					value = calculateContinuousTarget(valueFactory, name, nearestInstanceResults, table);</span>
<span class="fc" id="L226">					break;</span>
				case CATEGORICAL:
<span class="fc" id="L228">					value = calculateCategoricalTarget(valueFactory, name, nearestInstanceResults, table);</span>
<span class="fc" id="L229">					break;</span>
				default:
<span class="nc" id="L231">					throw new InvalidElementException(nearestNeighborModel);</span>
			}

<span class="fc" id="L234">			value = TypeUtil.parseOrCast(targetField.getDataType(), value);</span>

<span class="fc" id="L236">			AffinityDistribution&lt;V&gt; result = createAffinityDistribution(instanceResults, function, value);</span>

<span class="fc" id="L238">			results.put(name, result);</span>
<span class="fc" id="L239">		}</span>

<span class="fc" id="L241">		return results;</span>
	}

	@Override
	protected &lt;V extends Number&gt; Map&lt;FieldName, AffinityDistribution&lt;V&gt;&gt; evaluateClustering(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="fc" id="L246">		NearestNeighborModel nearestNeighborModel = getModel();</span>

<span class="fc" id="L248">		Table&lt;Integer, FieldName, FieldValue&gt; table = getTrainingInstances();</span>

<span class="fc" id="L250">		List&lt;InstanceResult&lt;V&gt;&gt; instanceResults = evaluateInstanceRows(valueFactory, context);</span>

<span class="fc" id="L252">		FieldName instanceIdVariable = nearestNeighborModel.getInstanceIdVariable();</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">		if(instanceIdVariable == null){</span>
<span class="nc" id="L254">			throw new MissingAttributeException(nearestNeighborModel, PMMLAttributes.NEARESTNEIGHBORMODEL_INSTANCEIDVARIABLE);</span>
		}

<span class="fc" id="L257">		Function&lt;Integer, String&gt; function = createIdentifierResolver(instanceIdVariable, table);</span>

<span class="fc" id="L259">		AffinityDistribution&lt;V&gt; result = createAffinityDistribution(instanceResults, function, null);</span>

<span class="fc" id="L261">		return Collections.singletonMap(getTargetName(), result);</span>
	}

	private &lt;V extends Number&gt; List&lt;InstanceResult&lt;V&gt;&gt; evaluateInstanceRows(ValueFactory&lt;V&gt; valueFactory, EvaluationContext context){
<span class="fc" id="L265">		NearestNeighborModel nearestNeighborModel = getModel();</span>

<span class="fc" id="L267">		ComparisonMeasure comparisonMeasure = nearestNeighborModel.getComparisonMeasure();</span>

<span class="fc" id="L269">		List&lt;FieldValue&gt; values = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L271">		KNNInputs knnInputs = nearestNeighborModel.getKNNInputs();</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">		for(KNNInput knnInput : knnInputs){</span>
<span class="fc" id="L273">			FieldName name = knnInput.getField();</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">			if(name == null){</span>
<span class="nc" id="L275">				throw new MissingAttributeException(knnInput, PMMLAttributes.KNNINPUT_FIELD);</span>
			}

<span class="fc" id="L278">			FieldValue value = context.evaluate(name);</span>

<span class="fc" id="L280">			values.add(value);</span>
<span class="fc" id="L281">		}</span>

<span class="fc" id="L283">		Measure measure = MeasureUtil.ensureMeasure(comparisonMeasure);</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">		if(measure instanceof Similarity){</span>
<span class="fc" id="L286">			return evaluateSimilarity(valueFactory, comparisonMeasure, knnInputs.getKNNInputs(), values);</span>
		} else

<span class="pc bpc" id="L289" title="1 of 2 branches missed.">		if(measure instanceof Distance){</span>
<span class="fc" id="L290">			return evaluateDistance(valueFactory, comparisonMeasure, knnInputs.getKNNInputs(), values);</span>
		} else

		{
<span class="nc" id="L294">			throw new UnsupportedElementException(measure);</span>
		}
	}

	private &lt;V extends Number&gt; List&lt;InstanceResult&lt;V&gt;&gt; evaluateSimilarity(ValueFactory&lt;V&gt; valueFactory, ComparisonMeasure comparisonMeasure, List&lt;KNNInput&gt; knnInputs, List&lt;FieldValue&gt; values){
<span class="fc" id="L299">		BitSet flags = MeasureUtil.toBitSet(values);</span>

<span class="fc" id="L301">		Map&lt;Integer, BitSet&gt; flagMap = getInstanceFlags();</span>

<span class="fc" id="L303">		List&lt;InstanceResult&lt;V&gt;&gt; result = new ArrayList&lt;&gt;(flagMap.size());</span>

<span class="fc" id="L305">		Set&lt;Integer&gt; rowKeys = flagMap.keySet();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">		for(Integer rowKey : rowKeys){</span>
<span class="fc" id="L307">			BitSet instanceFlags = flagMap.get(rowKey);</span>

<span class="fc" id="L309">			Value&lt;V&gt; similarity = MeasureUtil.evaluateSimilarity(valueFactory, comparisonMeasure, knnInputs, flags, instanceFlags);</span>

<span class="fc" id="L311">			result.add(new InstanceResult.Similarity&lt;&gt;(rowKey, similarity));</span>
<span class="fc" id="L312">		}</span>

<span class="fc" id="L314">		return result;</span>
	}

	private &lt;V extends Number&gt; List&lt;InstanceResult&lt;V&gt;&gt; evaluateDistance(ValueFactory&lt;V&gt; valueFactory, ComparisonMeasure comparisonMeasure, List&lt;KNNInput&gt; knnInputs, List&lt;FieldValue&gt; values){
<span class="fc" id="L318">		Map&lt;Integer, List&lt;FieldValue&gt;&gt; valueMap = getInstanceValues();</span>

<span class="fc" id="L320">		List&lt;InstanceResult&lt;V&gt;&gt; result = new ArrayList&lt;&gt;(valueMap.size());</span>

<span class="fc" id="L322">		Value&lt;V&gt; adjustment = MeasureUtil.calculateAdjustment(valueFactory, values);</span>

<span class="fc" id="L324">		Set&lt;Integer&gt; rowKeys = valueMap.keySet();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">		for(Integer rowKey : rowKeys){</span>
<span class="fc" id="L326">			List&lt;FieldValue&gt; instanceValues = valueMap.get(rowKey);</span>

<span class="fc" id="L328">			Value&lt;V&gt; distance = MeasureUtil.evaluateDistance(valueFactory, comparisonMeasure, knnInputs, values, instanceValues, adjustment);</span>

<span class="fc" id="L330">			result.add(new InstanceResult.Distance&lt;&gt;(rowKey, distance));</span>
<span class="fc" id="L331">		}</span>

<span class="fc" id="L333">		return result;</span>
	}

	private &lt;V extends Number&gt; V calculateContinuousTarget(ValueFactory&lt;V&gt; valueFactory, FieldName name, List&lt;InstanceResult&lt;V&gt;&gt; instanceResults, Table&lt;Integer, FieldName, FieldValue&gt; table){
<span class="fc" id="L337">		NearestNeighborModel nearestNeighborModel = getModel();</span>

<span class="fc" id="L339">		NearestNeighborModel.ContinuousScoringMethod continuousScoringMethod = nearestNeighborModel.getContinuousScoringMethod();</span>

		ValueAggregator&lt;V&gt; aggregator;

<span class="pc bpc" id="L343" title="3 of 4 branches missed.">		switch(continuousScoringMethod){</span>
			case AVERAGE:
<span class="fc" id="L345">				aggregator = new ValueAggregator&lt;&gt;(valueFactory.newVector(0));</span>
<span class="fc" id="L346">				break;</span>
			case WEIGHTED_AVERAGE:
<span class="nc" id="L348">				aggregator = new ValueAggregator&lt;&gt;(valueFactory.newVector(0), valueFactory.newVector(0), valueFactory.newVector(0));</span>
<span class="nc" id="L349">				break;</span>
			case MEDIAN:
<span class="nc" id="L351">				aggregator = new ValueAggregator&lt;&gt;(valueFactory.newVector(instanceResults.size()));</span>
<span class="nc" id="L352">				break;</span>
			default:
<span class="nc" id="L354">				throw new UnsupportedAttributeException(nearestNeighborModel, continuousScoringMethod);</span>
		}

<span class="fc bfc" id="L357" title="All 2 branches covered.">		for(InstanceResult&lt;V&gt; instanceResult : instanceResults){</span>
<span class="fc" id="L358">			FieldValue value = table.get(instanceResult.getId(), name);</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">			if(FieldValueUtil.isMissing(value)){</span>
<span class="nc" id="L360">				throw new MissingValueException(name);</span>
			}

<span class="fc" id="L363">			Number number = value.asNumber();</span>

<span class="pc bpc" id="L365" title="2 of 3 branches missed.">			switch(continuousScoringMethod){</span>
				case AVERAGE:
				case MEDIAN:
<span class="fc" id="L368">					aggregator.add(number);</span>
<span class="fc" id="L369">					break;</span>
				case WEIGHTED_AVERAGE:
<span class="nc" id="L371">					InstanceResult.Distance distance = TypeUtil.cast(InstanceResult.Distance.class, instanceResult);</span>

<span class="nc" id="L373">					Value&lt;V&gt; weight = distance.getWeight(nearestNeighborModel.getThreshold());</span>

<span class="nc" id="L375">					aggregator.add(number, weight.doubleValue());</span>
<span class="nc" id="L376">					break;</span>
				default:
<span class="nc" id="L378">					throw new UnsupportedAttributeException(nearestNeighborModel, continuousScoringMethod);</span>
			}
<span class="fc" id="L380">		}</span>

<span class="pc bpc" id="L382" title="3 of 4 branches missed.">		switch(continuousScoringMethod){</span>
			case AVERAGE:
<span class="fc" id="L384">				return (aggregator.average()).getValue();</span>
			case WEIGHTED_AVERAGE:
<span class="nc" id="L386">				return (aggregator.weightedAverage()).getValue();</span>
			case MEDIAN:
<span class="nc" id="L388">				return (aggregator.median()).getValue();</span>
			default:
<span class="nc" id="L390">				throw new UnsupportedAttributeException(nearestNeighborModel, continuousScoringMethod);</span>
		}
	}

	@SuppressWarnings (
		value = {&quot;rawtypes&quot;, &quot;unchecked&quot;}
	)
	private &lt;V extends Number&gt; Object calculateCategoricalTarget(ValueFactory&lt;V&gt; valueFactory, FieldName name, List&lt;InstanceResult&lt;V&gt;&gt; instanceResults, Table&lt;Integer, FieldName, FieldValue&gt; table){
<span class="fc" id="L398">		NearestNeighborModel nearestNeighborModel = getModel();</span>

<span class="fc" id="L400">		VoteAggregator&lt;Object, V&gt; aggregator = new VoteAggregator&lt;Object, V&gt;(){</span>

			@Override
			public ValueFactory&lt;V&gt; getValueFactory(){
<span class="fc" id="L404">				return valueFactory;</span>
			}
		};

<span class="fc" id="L408">		NearestNeighborModel.CategoricalScoringMethod categoricalScoringMethod = nearestNeighborModel.getCategoricalScoringMethod();</span>

<span class="fc bfc" id="L410" title="All 2 branches covered.">		for(InstanceResult&lt;V&gt; instanceResult : instanceResults){</span>
<span class="fc" id="L411">			FieldValue value = table.get(instanceResult.getId(), name);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">			if(FieldValueUtil.isMissing(value)){</span>
<span class="nc" id="L413">				throw new MissingValueException(name);</span>
			}

<span class="fc" id="L416">			Object object = value.getValue();</span>

<span class="pc bpc" id="L418" title="2 of 3 branches missed.">			switch(categoricalScoringMethod){</span>
				case MAJORITY_VOTE:
<span class="fc" id="L420">					aggregator.add(object);</span>
<span class="fc" id="L421">					break;</span>
				case WEIGHTED_MAJORITY_VOTE:
<span class="nc" id="L423">					InstanceResult.Distance distance = TypeUtil.cast(InstanceResult.Distance.class, instanceResult);</span>

<span class="nc" id="L425">					Value&lt;V&gt; weight = distance.getWeight(nearestNeighborModel.getThreshold());</span>

<span class="nc" id="L427">					aggregator.add(object, weight.doubleValue());</span>
<span class="nc" id="L428">					break;</span>
				default:
<span class="nc" id="L430">					throw new UnsupportedAttributeException(nearestNeighborModel, categoricalScoringMethod);</span>
			}
<span class="fc" id="L432">		}</span>

<span class="fc" id="L434">		Set&lt;Object&gt; winners = aggregator.getWinners();</span>

		// &quot;In case of a tie, the category with the largest number of cases in the training data is the winner&quot;
<span class="fc bfc" id="L437" title="All 2 branches covered.">		if(winners.size() &gt; 1){</span>
<span class="fc" id="L438">			Multiset&lt;Object&gt; multiset = LinkedHashMultiset.create();</span>

<span class="fc" id="L440">			Map&lt;Integer, FieldValue&gt; column = table.column(name);</span>

<span class="fc" id="L442">			multiset.addAll(Collections2.transform(column.values(), FieldValue::getValue));</span>

<span class="fc" id="L444">			aggregator.clear();</span>

<span class="fc bfc" id="L446" title="All 2 branches covered.">			for(Object winner : winners){</span>
<span class="fc" id="L447">				aggregator.add(winner, multiset.count(winner));</span>
<span class="fc" id="L448">			}</span>

<span class="fc" id="L450">			winners = aggregator.getWinners();</span>

			// &quot;If multiple categories are tied on the largest number of cases in the training data, then the category with the smallest data value (in lexical order) among the tied categories is the winner&quot;
<span class="fc bfc" id="L453" title="All 2 branches covered.">			if(winners.size() &gt; 1){</span>
<span class="fc" id="L454">				return Collections.min((Collection)winners);</span>
			}
		}

<span class="fc" id="L458">		return Iterables.getFirst(winners, null);</span>
	}

	private Function&lt;Integer, String&gt; createIdentifierResolver(FieldName name, Table&lt;Integer, FieldName, FieldValue&gt; table){
<span class="fc" id="L462">		Function&lt;Integer, String&gt; function = new Function&lt;Integer, String&gt;(){</span>

			@Override
			public String apply(Integer row){
<span class="fc" id="L466">				FieldValue value = table.get(row, name);</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">				if(FieldValueUtil.isMissing(value)){</span>
<span class="nc" id="L468">					throw new MissingValueException(name);</span>
				}

<span class="fc" id="L471">				return value.asString();</span>
			}
		};

<span class="fc" id="L475">		return function;</span>
	}

	private &lt;V extends Number&gt; AffinityDistribution&lt;V&gt; createAffinityDistribution(List&lt;InstanceResult&lt;V&gt;&gt; instanceResults, Function&lt;Integer, String&gt; function, Object result){
<span class="fc" id="L479">		NearestNeighborModel nearestNeighborModel = getModel();</span>

<span class="fc" id="L481">		ComparisonMeasure comparisonMeasure = nearestNeighborModel.getComparisonMeasure();</span>

<span class="fc" id="L483">		ValueMap&lt;String, V&gt; values = new ValueMap&lt;&gt;(2 * instanceResults.size());</span>

<span class="fc bfc" id="L485" title="All 2 branches covered.">		for(InstanceResult&lt;V&gt; instanceResult : instanceResults){</span>
<span class="fc" id="L486">			values.put(function.apply(instanceResult.getId()), instanceResult.getValue());</span>
<span class="fc" id="L487">		}</span>

<span class="fc" id="L489">		Measure measure = MeasureUtil.ensureMeasure(comparisonMeasure);</span>

<span class="fc bfc" id="L491" title="All 2 branches covered.">		if(measure instanceof Similarity){</span>
<span class="fc" id="L492">			return new AffinityDistribution&lt;&gt;(Classification.Type.SIMILARITY, values, result);</span>
		} else

<span class="pc bpc" id="L495" title="1 of 2 branches missed.">		if(measure instanceof Distance){</span>
<span class="fc" id="L496">			return new AffinityDistribution&lt;&gt;(Classification.Type.DISTANCE, values, result);</span>
		} else

		{
<span class="nc" id="L500">			throw new UnsupportedElementException(measure);</span>
		}
	}

	private Table&lt;Integer, FieldName, FieldValue&gt; getTrainingInstances(){

<span class="pc bpc" id="L506" title="1 of 2 branches missed.">		if(this.trainingInstances == null){</span>
<span class="fc" id="L507">			this.trainingInstances = getValue(NearestNeighborModelEvaluator.trainingInstanceCache, createTrainingInstanceLoader(this));</span>
		}

<span class="fc" id="L510">		return this.trainingInstances;</span>
	}

	static
	private Callable&lt;Table&lt;Integer, FieldName, FieldValue&gt;&gt; createTrainingInstanceLoader(NearestNeighborModelEvaluator modelEvaluator){
<span class="fc" id="L515">		return new Callable&lt;Table&lt;Integer, FieldName, FieldValue&gt;&gt;(){</span>

			@Override
			public Table&lt;Integer, FieldName, FieldValue&gt; call(){
<span class="fc" id="L519">				return parseTrainingInstances(modelEvaluator);</span>
			}
		};
	}

	static
	private Table&lt;Integer, FieldName, FieldValue&gt; parseTrainingInstances(NearestNeighborModelEvaluator modelEvaluator){
<span class="fc" id="L526">		NearestNeighborModel nearestNeighborModel = modelEvaluator.getModel();</span>

<span class="fc" id="L528">		FieldName instanceIdVariable = nearestNeighborModel.getInstanceIdVariable();</span>

<span class="fc" id="L530">		Set&lt;FieldName&gt; names = new HashSet&lt;&gt;();</span>

<span class="fc" id="L532">		FieldReferenceFinder variableFinder = new FieldReferenceFinder();</span>
<span class="fc" id="L533">		variableFinder.applyTo(nearestNeighborModel);</span>

<span class="fc" id="L535">		names.addAll(variableFinder.getFieldNames());</span>

<span class="fc" id="L537">		List&lt;TargetField&gt; targetFields = modelEvaluator.getTargetFields();</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">		for(TargetField targetField : targetFields){</span>
<span class="fc" id="L539">			names.add(targetField.getFieldName());</span>
<span class="fc" id="L540">		}</span>

<span class="fc" id="L542">		TrainingInstances trainingInstances = nearestNeighborModel.getTrainingInstances();</span>

<span class="fc" id="L544">		List&lt;FieldLoader&gt; fieldLoaders = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L546">		InstanceFields instanceFields = trainingInstances.getInstanceFields();</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">		for(InstanceField instanceField : instanceFields){</span>
<span class="fc" id="L548">			FieldName name = instanceField.getField();</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">			if(name == null){</span>
<span class="nc" id="L550">				throw new MissingAttributeException(instanceField, PMMLAttributes.INSTANCEFIELD_FIELD);</span>
			}

<span class="fc" id="L553">			String column = instanceField.getColumn();</span>

<span class="fc bfc" id="L555" title="All 4 branches covered.">			if(instanceIdVariable != null &amp;&amp; (instanceIdVariable).equals(name)){</span>
<span class="fc" id="L556">				fieldLoaders.add(new IdentifierLoader(name, column));</span>

<span class="fc" id="L558">				continue;</span>
			} // End if

<span class="fc bfc" id="L561" title="All 2 branches covered.">			if(!names.contains(name)){</span>
<span class="fc" id="L562">				continue;</span>
			}

<span class="fc" id="L565">			Field&lt;?&gt; field = modelEvaluator.resolveField(name);</span>
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">			if(field == null){</span>
<span class="nc" id="L567">				throw new MissingFieldException(name, instanceField);</span>
			} // End if

<span class="pc bpc" id="L570" title="1 of 2 branches missed.">			if(field instanceof DataField){</span>
<span class="fc" id="L571">				DataField dataField = (DataField)field;</span>

<span class="fc" id="L573">				MiningField miningField = modelEvaluator.getMiningField(name);</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">				if(miningField == null){</span>
<span class="nc" id="L575">					throw new InvisibleFieldException(name, instanceField);</span>
				}

<span class="fc" id="L578">				fieldLoaders.add(new DataFieldLoader(name, column, dataField, miningField));</span>
<span class="fc" id="L579">			} else</span>

<span class="nc bnc" id="L581" title="All 2 branches missed.">			if(field instanceof DerivedField){</span>
<span class="nc" id="L582">				DerivedField derivedField = (DerivedField)field;</span>

<span class="nc" id="L584">				fieldLoaders.add(new DerivedFieldLoader(name, column, derivedField));</span>
<span class="nc" id="L585">			} else</span>

			{
<span class="nc" id="L588">				throw new InvalidAttributeException(instanceField, PMMLAttributes.INSTANCEFIELD_FIELD, name);</span>
			}
<span class="fc" id="L590">		}</span>

<span class="fc" id="L592">		Table&lt;Integer, FieldName, FieldValue&gt; result = HashBasedTable.create();</span>

<span class="fc" id="L594">		InlineTable inlineTable = InlineTableUtil.getInlineTable(trainingInstances);</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">		if(inlineTable != null){</span>
<span class="fc" id="L596">			Table&lt;Integer, String, Object&gt; table = InlineTableUtil.getContent(inlineTable);</span>

<span class="fc" id="L598">			Set&lt;Integer&gt; rowKeys = table.rowKeySet();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">			for(Integer rowKey : rowKeys){</span>
<span class="fc" id="L600">				Map&lt;String, Object&gt; rowValues = table.row(rowKey);</span>

<span class="fc bfc" id="L602" title="All 2 branches covered.">				for(FieldLoader fieldLoader : fieldLoaders){</span>
<span class="fc" id="L603">					result.put(rowKey, fieldLoader.getName(), fieldLoader.load(rowValues));</span>
<span class="fc" id="L604">				}</span>
<span class="fc" id="L605">			}</span>
		}

<span class="fc" id="L608">		KNNInputs knnInputs = nearestNeighborModel.getKNNInputs();</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">		for(KNNInput knnInput : knnInputs){</span>
<span class="fc" id="L610">			FieldName name = knnInput.getField();</span>

<span class="fc" id="L612">			DerivedField derivedField = modelEvaluator.resolveDerivedField(name);</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">			if(derivedField == null){</span>
<span class="fc" id="L614">				continue;</span>
			}

<span class="fc" id="L617">			Set&lt;Integer&gt; rowKeys = result.rowKeySet();</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">			for(Integer rowKey : rowKeys){</span>
<span class="fc" id="L619">				Map&lt;FieldName, FieldValue&gt; rowValues = result.row(rowKey);</span>

<span class="pc bpc" id="L621" title="1 of 2 branches missed.">				if(rowValues.containsKey(name)){</span>
<span class="nc" id="L622">					continue;</span>
				}

<span class="fc" id="L625">				ModelEvaluationContext context = modelEvaluator.createEvaluationContext();</span>
<span class="fc" id="L626">				context.declareAll(rowValues);</span>

<span class="fc" id="L628">				FieldValue value = ExpressionUtil.evaluateTypedExpressionContainer(derivedField, context);</span>

<span class="fc" id="L630">				result.put(rowKey, name, value);</span>
<span class="fc" id="L631">			}</span>
<span class="fc" id="L632">		}</span>

<span class="fc" id="L634">		int numberOfNeighbors = nearestNeighborModel.getNumberOfNeighbors();</span>
<span class="pc bpc" id="L635" title="2 of 4 branches missed.">		if(numberOfNeighbors &lt; 0 || result.size() &lt; numberOfNeighbors){</span>
<span class="nc" id="L636">			throw new InvalidAttributeException(nearestNeighborModel, PMMLAttributes.NEARESTNEIGHBORMODEL_NUMBEROFNEIGHBORS, numberOfNeighbors);</span>
		}

<span class="fc" id="L639">		return result;</span>
	}

	private Map&lt;Integer, BitSet&gt; getInstanceFlags(){

<span class="pc bpc" id="L644" title="1 of 2 branches missed.">		if(this.instanceFlags == null){</span>
<span class="fc" id="L645">			this.instanceFlags = getValue(NearestNeighborModelEvaluator.instanceFlagCache, createInstanceFlagLoader(this));</span>
		}

<span class="fc" id="L648">		return this.instanceFlags;</span>
	}

	static
	private Callable&lt;Map&lt;Integer, BitSet&gt;&gt; createInstanceFlagLoader(NearestNeighborModelEvaluator modelEvaluator){
<span class="fc" id="L653">		return new Callable&lt;Map&lt;Integer, BitSet&gt;&gt;(){</span>

			@Override
			public Map&lt;Integer, BitSet&gt; call(){
<span class="fc" id="L657">				return loadInstanceFlags(modelEvaluator);</span>
			}
		};
	}

	static
	private Map&lt;Integer, BitSet&gt; loadInstanceFlags(NearestNeighborModelEvaluator modelEvaluator){
<span class="fc" id="L664">		Map&lt;Integer, BitSet&gt; result = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L666">		Map&lt;Integer, List&lt;FieldValue&gt;&gt; valueMap = modelEvaluator.getValue(NearestNeighborModelEvaluator.instanceValueCache, createInstanceValueLoader(modelEvaluator));</span>

<span class="fc" id="L668">		Maps.EntryTransformer&lt;Integer, List&lt;FieldValue&gt;, BitSet&gt; transformer = new Maps.EntryTransformer&lt;Integer, List&lt;FieldValue&gt;, BitSet&gt;(){</span>

			@Override
			public BitSet transformEntry(Integer key, List&lt;FieldValue&gt; value){
<span class="fc" id="L672">				return MeasureUtil.toBitSet(value);</span>
			}
		};
<span class="fc" id="L675">		result.putAll(Maps.transformEntries(valueMap, transformer));</span>

<span class="fc" id="L677">		return result;</span>
	}

	private Map&lt;Integer, List&lt;FieldValue&gt;&gt; getInstanceValues(){

<span class="pc bpc" id="L682" title="1 of 2 branches missed.">		if(this.instanceValues == null){</span>
<span class="fc" id="L683">			this.instanceValues = getValue(NearestNeighborModelEvaluator.instanceValueCache, createInstanceValueLoader(this));</span>
		}

<span class="fc" id="L686">		return this.instanceValues;</span>
	}

	static
	private Callable&lt;Map&lt;Integer, List&lt;FieldValue&gt;&gt;&gt; createInstanceValueLoader(NearestNeighborModelEvaluator modelEvaluator){
<span class="fc" id="L691">		return new Callable&lt;Map&lt;Integer, List&lt;FieldValue&gt;&gt;&gt;(){</span>

			@Override
			public Map&lt;Integer, List&lt;FieldValue&gt;&gt; call(){
<span class="fc" id="L695">				return loadInstanceValues(modelEvaluator);</span>
			}
		};
	}

	static
	private Map&lt;Integer, List&lt;FieldValue&gt;&gt; loadInstanceValues(NearestNeighborModelEvaluator modelEvaluator){
<span class="fc" id="L702">		NearestNeighborModel nearestNeighborModel = modelEvaluator.getModel();</span>

<span class="fc" id="L704">		Map&lt;Integer, List&lt;FieldValue&gt;&gt; result = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L706">		Table&lt;Integer, FieldName, FieldValue&gt; table = modelEvaluator.getValue(NearestNeighborModelEvaluator.trainingInstanceCache, createTrainingInstanceLoader(modelEvaluator));</span>

<span class="fc" id="L708">		KNNInputs knnInputs = nearestNeighborModel.getKNNInputs();</span>

<span class="fc" id="L710">		Set&lt;Integer&gt; rowKeys = ImmutableSortedSet.copyOf(table.rowKeySet());</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">		for(Integer rowKey : rowKeys){</span>
<span class="fc" id="L712">			List&lt;FieldValue&gt; values = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L714">			Map&lt;FieldName, FieldValue&gt; rowValues = table.row(rowKey);</span>

<span class="fc bfc" id="L716" title="All 2 branches covered.">			for(KNNInput knnInput : knnInputs){</span>
<span class="fc" id="L717">				FieldValue value = rowValues.get(knnInput.getField());</span>

<span class="fc" id="L719">				values.add(value);</span>
<span class="fc" id="L720">			}</span>

<span class="fc" id="L722">			result.put(rowKey, values);</span>
<span class="fc" id="L723">		}</span>

<span class="fc" id="L725">		return result;</span>
	}

	static
	abstract
	private class FieldLoader {

<span class="fc" id="L732">		private FieldName name = null;</span>

<span class="fc" id="L734">		private String column = null;</span>


<span class="fc" id="L737">		private FieldLoader(FieldName name, String column){</span>
<span class="fc" id="L738">			setName(name);</span>
<span class="fc" id="L739">			setColumn(column);</span>
<span class="fc" id="L740">		}</span>

		abstract
		public FieldValue prepare(Object value);

		public FieldValue load(Map&lt;String, Object&gt; values){
<span class="fc" id="L746">			Object value = values.get(getColumn());</span>

<span class="fc" id="L748">			return prepare(value);</span>
		}

		public FieldName getName(){
<span class="fc" id="L752">			return this.name;</span>
		}

		private void setName(FieldName name){
<span class="fc" id="L756">			this.name = name;</span>
<span class="fc" id="L757">		}</span>

		public String getColumn(){
<span class="fc" id="L760">			return this.column;</span>
		}

		private void setColumn(String column){
<span class="fc" id="L764">			this.column = column;</span>
<span class="fc" id="L765">		}</span>
	}

	static
	private class IdentifierLoader extends FieldLoader {

		private IdentifierLoader(FieldName name, String column){
<span class="fc" id="L772">			super(name, column);</span>
<span class="fc" id="L773">		}</span>

		@Override
		public FieldValue prepare(Object value){
<span class="fc" id="L777">			return FieldValueUtil.create(TypeInfos.CATEGORICAL_STRING, value);</span>
		}
	}

	static
	private class DataFieldLoader extends FieldLoader {

<span class="fc" id="L784">		private DataField dataField = null;</span>

<span class="fc" id="L786">		private MiningField miningField = null;</span>


		private DataFieldLoader(FieldName name, String column, DataField dataField, MiningField miningField){
<span class="fc" id="L790">			super(name, column);</span>

<span class="fc" id="L792">			setDataField(dataField);</span>
<span class="fc" id="L793">			setMiningField(miningField);</span>
<span class="fc" id="L794">		}</span>

		@Override
		public FieldValue prepare(Object value){
<span class="fc" id="L798">			return InputFieldUtil.prepareInputValue(getDataField(), getMiningField(), value);</span>
		}

		public DataField getDataField(){
<span class="fc" id="L802">			return this.dataField;</span>
		}

		private void setDataField(DataField dataField){
<span class="fc" id="L806">			this.dataField = dataField;</span>
<span class="fc" id="L807">		}</span>

		public MiningField getMiningField(){
<span class="fc" id="L810">			return this.miningField;</span>
		}

		private void setMiningField(MiningField miningField){
<span class="fc" id="L814">			this.miningField = miningField;</span>
<span class="fc" id="L815">		}</span>
	}

	static
	private class DerivedFieldLoader extends FieldLoader {

<span class="nc" id="L821">		private DerivedField derivedField = null;</span>


		private DerivedFieldLoader(FieldName name, String column, DerivedField derivedField){
<span class="nc" id="L825">			super(name, column);</span>

<span class="nc" id="L827">			setDerivedField(derivedField);</span>
<span class="nc" id="L828">		}</span>

		@Override
		public FieldValue prepare(Object value){
<span class="nc" id="L832">			DerivedField derivedField = getDerivedField();</span>

<span class="nc" id="L834">			TypeInfo typeInfo = new TypeInfo(){</span>

				@Override
				public DataType getDataType(){
<span class="nc" id="L838">					DataType dataType = derivedField.getDataType();</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">					if(dataType == null){</span>
<span class="nc" id="L840">						throw new MissingAttributeException(derivedField, PMMLAttributes.DERIVEDFIELD_DATATYPE);</span>
					}

<span class="nc" id="L843">					return dataType;</span>
				}

				@Override
				public OpType getOpType(){
<span class="nc" id="L848">					OpType opType = derivedField.getOpType();</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">					if(opType == null){</span>
<span class="nc" id="L850">						throw new MissingAttributeException(derivedField, PMMLAttributes.DERIVEDFIELD_OPTYPE);</span>
					}

<span class="nc" id="L853">					return opType;</span>
				}

				@Override
				public List&lt;?&gt; getOrdering(){
<span class="nc" id="L858">					List&lt;?&gt; ordering = FieldUtil.getValidValues(derivedField);</span>

<span class="nc" id="L860">					return ordering;</span>
				}
			};

<span class="nc" id="L864">			return FieldValueUtil.create(typeInfo, value);</span>
		}

		public DerivedField getDerivedField(){
<span class="nc" id="L868">			return this.derivedField;</span>
		}

		private void setDerivedField(DerivedField derivedField){
<span class="nc" id="L872">			this.derivedField = derivedField;</span>
<span class="nc" id="L873">		}</span>
	}

	static
	abstract
	private class InstanceResult&lt;V extends Number&gt; implements Comparable&lt;InstanceResult&lt;V&gt;&gt; {

<span class="fc" id="L880">		private Integer id = null;</span>

<span class="fc" id="L882">		private Value&lt;V&gt; value = null;</span>


<span class="fc" id="L885">		private InstanceResult(Integer id, Value&lt;V&gt; value){</span>
<span class="fc" id="L886">			setId(id);</span>
<span class="fc" id="L887">			setValue(value);</span>
<span class="fc" id="L888">		}</span>

		public Integer getId(){
<span class="fc" id="L891">			return this.id;</span>
		}

		private void setId(Integer id){
<span class="fc" id="L895">			this.id = id;</span>
<span class="fc" id="L896">		}</span>

		public Value&lt;V&gt; getValue(){
<span class="fc" id="L899">			return this.value;</span>
		}

		private void setValue(Value&lt;V&gt; value){
<span class="fc" id="L903">			this.value = value;</span>
<span class="fc" id="L904">		}</span>

		static
		private class Similarity&lt;V extends Number&gt; extends InstanceResult&lt;V&gt; {

			private Similarity(Integer id, Value&lt;V&gt; value){
<span class="fc" id="L910">				super(id, value);</span>
<span class="fc" id="L911">			}</span>

			@Override
			public int compareTo(InstanceResult&lt;V&gt; that){

<span class="nc bnc" id="L916" title="All 2 branches missed.">				if(that instanceof Similarity){</span>
<span class="nc" id="L917">					return Classification.Type.SIMILARITY.compareValues(this.getValue(), that.getValue());</span>
				}

<span class="nc" id="L920">				throw new ClassCastException();</span>
			}
		}

		static
		private class Distance&lt;V extends Number&gt; extends InstanceResult&lt;V&gt; {

			private Distance(Integer id, Value&lt;V&gt; value){
<span class="fc" id="L928">				super(id, value);</span>
<span class="fc" id="L929">			}</span>

			@Override
			public int compareTo(InstanceResult&lt;V&gt; that){

<span class="pc bpc" id="L934" title="1 of 2 branches missed.">				if(that instanceof Distance){</span>
<span class="fc" id="L935">					return Classification.Type.DISTANCE.compareValues(this.getValue(), that.getValue());</span>
				}

<span class="nc" id="L938">				throw new ClassCastException();</span>
			}

			public Value&lt;V&gt; getWeight(double threshold){
<span class="nc" id="L942">				Value&lt;V&gt; value = getValue();</span>

<span class="nc" id="L944">				value = value.copy();</span>

<span class="nc bnc" id="L946" title="All 2 branches missed.">				if(threshold != 0d){</span>
<span class="nc" id="L947">					value.add(threshold);</span>
				}

<span class="nc" id="L950">				return value.reciprocal();</span>
			}
		}
	}

<span class="fc" id="L955">	private static final Cache&lt;NearestNeighborModel, Table&lt;Integer, FieldName, FieldValue&gt;&gt; trainingInstanceCache = CacheUtil.buildCache();</span>

<span class="fc" id="L957">	private static final Cache&lt;NearestNeighborModel, Map&lt;Integer, BitSet&gt;&gt; instanceFlagCache = CacheUtil.buildCache();</span>

<span class="fc" id="L959">	private static final Cache&lt;NearestNeighborModel, Map&lt;Integer, List&lt;FieldValue&gt;&gt;&gt; instanceValueCache = CacheUtil.buildCache();</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.0.201801022044</span></div></body></html>